{% extends 'timesup/base.html' %}
{% load static %}

{% block title %}Playing - Times Up!{% endblock %}

{% block extra_css %}
<style>
body {
    background: {{ current_team.background_gradient }} !important;
}
</style>
{% endblock %}

{% block content %}
<div class="current-team" style="color: {{ current_team.text_color }};">
    <h2 class="team-name">{{ current_team.name }} - {{ current_team.total_score }}</h2>
</div>

<div class="play-container">
    <div class="game-header">
        <h1 style="font-size: 1.5rem;">{{ game.get_current_round_display }}</h1>
        <p class="game-code">Game: {{ game.code }}</p>
    </div>
    
    <div class="round-rules" style="display: none;">
        {% if game.current_round == 1 %}
        <h3>Rules: Open Description</h3>
        <ul>
            <li>‚úì Speak freely and use sentences</li>
            <li>‚úó Cannot say any part of the name</li>
            <li>‚úó Cannot spell or rhyme the name</li>
            <li>‚úó Cannot translate the name</li>
            <li>‚è±Ô∏è 30 seconds per turn</li>
            <li>üéØ Unlimited guesses</li>
            <li>‚ùå Cannot pass</li>
        </ul>
        {% elif game.current_round == 2 %}
        <h3>Rules: One Word</h3>
        <ul>
            <li>‚úì Say only ONE word per card</li>
            <li>‚úì Can repeat the word</li>
            <li>‚úì Gestures allowed after saying word</li>
            <li>‚úì Can pass to next card</li>
            <li>‚è±Ô∏è 30 seconds per turn</li>
            <li>üéØ Only ONE guess allowed</li>
        </ul>
        {% elif game.current_round == 3 %}
        <h3>Rules: The Mime</h3>
        <ul>
            <li>‚úì Use pantomime and gestures</li>
            <li>‚úì Sound effects allowed</li>
            <li>‚úì Can pass to next card</li>
            <li>‚úó NO WORDS allowed</li>
            <li>‚è±Ô∏è 30 seconds per turn</li>
            <li>üéØ Only ONE guess allowed</li>
        </ul>
        {% endif %}
    </div>
    
    <div class="timer-container">
        <div class="timer-display">
            <div id="timer" class="timer">{{ game.turn_duration }}</div>
            <div class="timer-label">seconds</div>
        </div>
        <div class="timer-buttons">
            <button id="undo-btn" class="btn btn-secondary btn-outline-danger" onclick="undoLastCard()" disabled>‚Ü∂ Undo</button>
            <button id="end-turn-btn" class="btn btn-outline-danger" onclick="endTurn()" style="display:none;">End Turn</button>
        </div>
    </div>
    
    <div class="card-display" id="card-display">
        <div class="card-placeholder">
            <p>Click "Start Turn" to begin</p>
        </div>
    </div>
    
    <div class="card-info">
        <div id="remaining-cards">Remaining: {{ remaining_cards }}/{{ total_cards }}</div>
    </div>
    
    <div class="game-controls">
        <button id="start-turn-btn" class="btn btn-primary btn-xlarge" onclick="startTurn()">Start Turn</button>
        {% if game.current_round > 1 %}
        <button id="pass-btn" class="btn btn-warning btn-xlarge" onclick="passCard()" style="display:none;">Pass ‚Üí</button>
        {% endif %}
        <button id="got-it-btn" class="btn btn-success btn-xlarge" onclick="cardGuessed()" style="display:none;">Got It! ‚úì</button>
    </div>
    
    <div class="scores-panel" style="display: none;">
        <h3>Current Scores</h3>
        {% for team in game.teams.all %}
        <div class="score-item">
            <span>{{ team.name }}:</span>
            <span>{{ team.total_score }}</span>
        </div>
        {% endfor %}
    </div>
</div>

<audio id="sfx-correct" preload="auto" src="{% static 'timesup/audio/correct.mp3' %}"></audio>
<audio id="sfx-warning" preload="auto" src="{% static 'timesup/audio/analog-time-5.mp3' %}"></audio>

<script>
let timerInterval = null;
let timeLeft = {{ game.turn_duration }};
let currentCard = null;
let allCards = []; // Preloaded cards for this turn
let cardIndex = 0; // Current position in cards array
let guessedCards = []; // Cards guessed this turn (with IDs)
let passedCards = []; // Cards passed this turn (indices)
let lastGuessedCard = null; // Track last guessed card for undo
let isProcessing = false; // Prevent double-clicks
const totalCards = {{ total_cards }};
const turnDuration = {{ game.turn_duration }};
const gameCode = '{{ game.code }}';
const currentTeamIndex = {{ game.current_team_index }};

// Sounds (Web Audio) - created only after user gesture (Start Turn)
let audioCtx = null;

function ensureAudio() {
    if (!audioCtx) {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return null;
        audioCtx = new Ctx();
    }
    if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(() => {});
    }
    return audioCtx;
}

function playTone({ frequency, durationMs, type = 'sine', gain = 0.06 }) {
    const ctx = ensureAudio();
    if (!ctx) return;

    const osc = ctx.createOscillator();
    const g = ctx.createGain();
    osc.type = type;
    osc.frequency.value = frequency;

    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(gain, ctx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + (durationMs / 1000));

    osc.connect(g);
    g.connect(ctx.destination);

    osc.start();
    osc.stop(ctx.currentTime + (durationMs / 1000) + 0.02);
}

function playGuessSound() {
    // Prefer custom audio; fallback to a short tone
    if (!playAudio('sfx-correct')) {
        playTone({ frequency: 880, durationMs: 90, type: 'triangle', gain: 0.05 });
    }
}

function playTimeUpSound() {
    // quick double-beep
    playTone({ frequency: 220, durationMs: 180, type: 'square', gain: 0.07 });
    setTimeout(() => playTone({ frequency: 165, durationMs: 220, type: 'square', gain: 0.07 }), 200);
}

// Check if there's a card from the previous turn that we should exclude
const lastCardKey = `lastCard_${gameCode}_round{{ game.current_round }}`;
const lastTeamKey = `lastTeam_${gameCode}_round{{ game.current_round }}`;
let excludeCardId = null;
let timeUpPlayed = false;
let warningStarted = false;
let excludeOnFirstPick = null;

function getAudioEl(id) {
    return document.getElementById(id);
}

async function primeAudio() {
    // Best-effort: unlock audio after the Start Turn click.
    const els = [getAudioEl('sfx-correct'), getAudioEl('sfx-warning')].filter(Boolean);
    for (const el of els) {
        const prevVolume = el.volume;
        try {
            el.volume = 0;
            el.currentTime = 0;
            await el.play();
            el.pause();
            el.currentTime = 0;
        } catch (e) {
            // Ignore autoplay restrictions; user may need another gesture.
        } finally {
            el.volume = prevVolume;
        }
    }
}

function playAudio(id) {
    const el = getAudioEl(id);
    if (!el) return false;
    try { el.currentTime = 0; } catch (e) {}
    el.play().catch(() => {});
    return true;
}

function stopAudio(id) {
    const el = getAudioEl(id);
    if (!el) return;
    try {
        el.pause();
        el.currentTime = 0;
    } catch (e) {}
}

function waitForAudioToFinish(id, maxWaitMs = 8000) {
    const el = getAudioEl(id);
    if (!el) return Promise.resolve();

    // If it isn't playing (or metadata unknown), don't block.
    if (el.paused) return Promise.resolve();

    let waitMs = maxWaitMs;
    if (Number.isFinite(el.duration) && Number.isFinite(el.currentTime)) {
        const remainingMs = Math.max(0, (el.duration - el.currentTime) * 1000);
        waitMs = Math.min(maxWaitMs, Math.ceil(remainingMs + 150));
    }

    return new Promise((resolve) => {
        let done = false;
        const finish = () => {
            if (done) return;
            done = true;
            try { el.removeEventListener('ended', finish); } catch (e) {}
            resolve();
        };

        try { el.addEventListener('ended', finish, { once: true }); } catch (e) {}
        setTimeout(finish, waitMs);
    });
}

function setWaitingForReloadUI(isWaiting) {
    const ids = ['got-it-btn', 'pass-btn', 'end-turn-btn', 'undo-btn'];
    for (const id of ids) {
        const el = document.getElementById(id);
        if (!el) continue;
        if (isWaiting) {
            el.disabled = true;
            el.style.opacity = '0.5';
            el.style.cursor = 'not-allowed';
            el.style.pointerEvents = 'none';
        }
    }

    const endBtn = document.getElementById('end-turn-btn');
    if (isWaiting && endBtn) {
        endBtn.textContent = 'Waiting for sound‚Ä¶';
        endBtn.style.display = 'inline-block';
    }
}

// If the team has changed, exclude the last card shown
const lastTeamIndex = sessionStorage.getItem(lastTeamKey);
if (lastTeamIndex !== null && parseInt(lastTeamIndex) !== currentTeamIndex) {
    excludeCardId = sessionStorage.getItem(lastCardKey);
}

async function startTurn() {
    if (isProcessing) return;
    isProcessing = true;

    // Initialize audio on user gesture (required by browsers)
    ensureAudio();
    await primeAudio();
    
    document.getElementById('start-turn-btn').style.display = 'none';
    document.getElementById('got-it-btn').style.display = 'inline-block';
    {% if game.current_round > 1 %}
    document.getElementById('pass-btn').style.display = 'inline-block';
    {% endif %}
    document.getElementById('end-turn-btn').style.display = 'inline-block';
    
    // Reset state
    document.getElementById('undo-btn').disabled = true;
    lastGuessedCard = null;
    guessedCards = [];
    passedCards = [];
    cardIndex = 0;
    timeUpPlayed = false;
    warningStarted = false;
    stopAudio('sfx-warning');

    // Only avoid showing the previous team's last card as the *first* card.
    // Do not exclude it from the whole deck (that can make a 40-card round appear as 39).
    excludeOnFirstPick = excludeCardId;
    
    // Preload all remaining cards for this turn
    let url = '{% url "timesup:get_card" game.code %}?all=true';
    
    const response = await fetch(url);
    const data = await response.json();
    
    if (data.complete) {
        window.location.href = '{% url "timesup:round_complete" game.code %}';
        return;
    }
    
    allCards = data.cards || [];
    
    if (allCards.length === 0) {
        window.location.href = '{% url "timesup:round_complete" game.code %}';
        return;
    }
    
    // Show first card
    showCurrentCard();
    
    // Start timer
    timeLeft = turnDuration;
    startTimer();
    isProcessing = false;
}

function startTimer() {
    timerInterval = setInterval(() => {
        timeLeft--;
        document.getElementById('timer').textContent = timeLeft;

        if (timeLeft === 5 && !warningStarted) {
            warningStarted = true;
            playAudio('sfx-warning');
        }
        
        if (timeLeft <= 5) {
            document.getElementById('timer').classList.add('timer-warning');
        }
        
        if (timeLeft <= 0) {
            clearInterval(timerInterval);
            timeUpPlayed = true;
            endTurn();
        }
    }, 1000);
}

function showCurrentCard() {
    // Find next unguessed, non-passed card
    let foundCard = false;
    let attempts = 0;

    const isGuessed = (cardId) => guessedCards.some(c => String(c.id) === String(cardId));
    
    while (!foundCard && attempts < allCards.length) {
        if (cardIndex >= allCards.length) {
            // Reset passed cards and start over
            passedCards = [];
            cardIndex = 0;
        }
        
        const candidate = allCards[cardIndex];
        const isExcludedFirst = excludeOnFirstPick && candidate && (String(candidate.id) === String(excludeOnFirstPick));
        if (!passedCards.includes(cardIndex) && candidate && !isGuessed(candidate.id) && !isExcludedFirst) {
            currentCard = candidate;
            foundCard = true;
            excludeOnFirstPick = null;
        } else {
            cardIndex++;
        }
        attempts++;
    }
    
    if (!foundCard || !currentCard) {
        // All cards passed or none available
        const fallbackIndex = allCards.findIndex(c => c && !isGuessed(c.id));
        if (fallbackIndex >= 0) {
            currentCard = allCards[fallbackIndex];
            cardIndex = fallbackIndex;
            passedCards = [];
        } else {
            return;
        }
    }
    
    // Store this card as the last shown card
    sessionStorage.setItem(lastCardKey, currentCard.id);
    sessionStorage.setItem(lastTeamKey, currentTeamIndex);
    
    document.getElementById('card-display').innerHTML = `
        <div class="card-content">
            <h2>${currentCard.name}</h2>
        </div>
    `;
    
    const remainingCount = allCards.length - guessedCards.length;
    document.getElementById('remaining-cards').textContent = `Remaining: ${remainingCount}/${totalCards}`;
}

async function cardGuessed() {
    if (!currentCard || isProcessing) return;
    isProcessing = true;
    
    // Disable button temporarily to prevent double-clicks
    const btn = document.getElementById('got-it-btn');
    btn.disabled = true;
    
    // Store the card we're marking as guessed
    lastGuessedCard = { 
        id: currentCard.id, 
        name: currentCard.name,
        index: cardIndex
    };
    guessedCards.push(lastGuessedCard);

    playGuessSound();
    
    // Enable undo button
    document.getElementById('undo-btn').disabled = false;
    
    // Check if all cards are guessed
    if (guessedCards.length >= allCards.length) {
        clearInterval(timerInterval);
        
        // Disable all buttons
        btn.disabled = true;
        const passBtn = document.getElementById('pass-btn');
        if (passBtn) passBtn.disabled = true;
        document.getElementById('end-turn-btn').disabled = true;
        document.getElementById('undo-btn').disabled = true;
        
        const results = await submitTurnResults();
        if (results && results.complete) {
            window.location.href = '{% url "timesup:round_complete" game.code %}';
            return;
        }

        // Not actually complete (e.g., an excluded/remaining card exists). Advance to next team.
        const response = await fetch('{% url "timesup:end_turn" game.code %}', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}'
            }
        });
        if (response.ok) {
            window.location.reload();
        }
        return;
    }
    
    // Move to next card
    cardIndex++;
    showCurrentCard();
    
    // Re-enable button
    btn.disabled = false;
    isProcessing = false;
}

async function passCard() {
    if (!currentCard || isProcessing) return;
    isProcessing = true;
    
    // Disable button temporarily
    const btn = document.getElementById('pass-btn');
    btn.disabled = true;
    
    // Mark current card as passed
    passedCards.push(cardIndex);
    
    // Move to next card
    cardIndex++;
    showCurrentCard();
    
    // Re-enable button
    btn.disabled = false;
    isProcessing = false;
}

async function undoLastCard() {
    if (!lastGuessedCard || isProcessing) return;
    isProcessing = true;
    
    // Remove from guessed cards
    guessedCards = guessedCards.filter(c => c.id !== lastGuessedCard.id);
    
    // Show the undone card again
    currentCard = lastGuessedCard;
    cardIndex = lastGuessedCard.index;
    
    document.getElementById('card-display').innerHTML = `
        <div class="card-content">
            <h2>${lastGuessedCard.name}</h2>
        </div>
    `;
    
    const remainingCount = allCards.length - guessedCards.length;
    document.getElementById('remaining-cards').textContent = `Remaining: ${remainingCount}/${totalCards}`;
    
    // Disable undo button
    document.getElementById('undo-btn').disabled = true;
    lastGuessedCard = null;
    
    isProcessing = false;
}

async function submitTurnResults() {
    // Submit all guessed cards at once
    const response = await fetch('{% url "timesup:submit_turn" game.code %}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': '{{ csrf_token }}'
        },
        body: JSON.stringify({ 
            guessed_card_ids: guessedCards.map(c => c.id)
        })
    });
    
    return await response.json();
}

async function endTurn() {
    if (isProcessing) return;
    clearInterval(timerInterval);
    isProcessing = true;
    
    // Disable all buttons
    document.getElementById('got-it-btn').disabled = true;
    const passBtn = document.getElementById('pass-btn');
    if (passBtn) passBtn.disabled = true;
    document.getElementById('end-turn-btn').disabled = true;
    
    // Submit results
    await submitTurnResults();
    
    // Move to next team
    const response = await fetch('{% url "timesup:end_turn" game.code %}', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': '{{ csrf_token }}'
        }
    });
    
    if (response.ok) {
        setWaitingForReloadUI(true);
        // Let the warning sound finish before reloading (otherwise the reload cuts audio).
        await waitForAudioToFinish('sfx-warning');
        window.location.reload();
    }
}
</script>
{% endblock %}
